#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  2 11:06:01 2023

@author: emielkoridon
"""

import itertools

import numpy as np

import torch
import openfermion

from auto_oo.main import integrals

def general_4index_transform(M, C0, C1, C2, C3):
    """
    M is a rank-4 tensor, Cs are rank-2 tensors representing ordered index 
    transformations of M
    """
    M = torch.einsum('pi, pqrs', C0, M)
    M = torch.einsum('qj, iqrs', C1, M)
    M = torch.einsum('rk, ijrs', C2, M)
    M = torch.einsum('sl, ijks', C3, M)
    return M

def uniform_4index_transform(M, C):
    """
    Autodifferentiable index transformation for two-electron tensor.
    
    Note: on a test case (dimension 13) this is 3x faster than optimized einsum,
        and >1000x more efficient than unoptimized einsum.
        Computing the Jacobian is also very efficient.
    """
    return general_4index_transform(M, C, C, C, C)

class OO_energy():
    def __init__(self, mol, ncas, nelecas,
                 mo_coeff=None, freeze_active=False):
        """
        Orbital Optimized energy class for extracting energies by computing RDMs
        from a quantum state generated by a quantum circuit. Can compute composite
        gradients and hessians with respect to both orbital and quantum circuit 
        parameters.

        Args:
            moldata_pyscf: Moldata class containing molecular information like
            geometry, AO basis, MO basis and 1e- and 2e-integrals
            ncas: Number of active orbitals
            nelecas: Number of active electrons
            mo_coeff (default None): Reference OAO-MO coefficients (ndarray)
            freeze_active (default: False):
                Freeze active-active oo indices
        """
        # Set molecular data
        self.int1e_AO = mol.int1e_AO
        self.int2e_AO = mol.int2e_AO
        self.overlap = mol.overlap
        self.oao_coeff = mol.oao_coeff
        self.nuc = mol.nuc
        self.nao = mol.nao
        
        if mo_coeff is None:
            mol.run_rhf()
            self.mo_coeff = mol.hf.mo_coeff
        else:
            self.mo_coeff = mo_coeff
        
        # Set active space parameters
        self.ncas = ncas
        self.nelecas = nelecas
        
        self.occ_idx, self.act_idx, self.virt_idx = mol.get_active_space_idx(
            ncas, nelecas)

        rotation_sizes = [len(self.occ_idx)*len(self.act_idx),
                          len(self.act_idx)*len(self.virt_idx),
                          len(self.occ_idx)*len(self.virt_idx)]
        if not freeze_active:
            rotation_sizes.append(
                len(self.act_idx) * (len(self.act_idx) - 1)//2)
        self.kappa_len = sum(rotation_sizes)

        # Save non-redundant kappa indices
        self.params_idx = np.array([], dtype=int)

        num = 0
        for l_idx, r_idx in zip(*np.tril_indices(self.nao,-1)):
            if not(
            ((l_idx in self.act_idx and r_idx in self.act_idx
              ) and freeze_active) or (
                  l_idx in self.occ_idx and r_idx in self.occ_idx) or (
                    l_idx in self.virt_idx and r_idx in self.virt_idx)):
                self.params_idx = np.append(self.params_idx, [num])
            num +=1
    
    
    def energy_from_mo_coeff(self, mo_coeff, one_rdm, two_rdm):
        r"""
        Get total energy given the one- and two-particle reduced density matrices
        :math:`\gamma_{pq}` and :math:`\Gamma_{pqrs}`.
        Total energy is thus:

        .. math::
            E = E_{\rm nuc} + E_{\rm core} +
            \sum_{pq}\tilde{h}_{pq} \gamma_{pq} + 
            \sum_{pqrs} g_{pqrs} \Gamma_{pqrs}

        where :math:`E_{core}` is the mean-field energy of the core (doubly-occupied) orbitals,
        :math:`\tilde{h}_{pq}` is contains the active one-body terms plus the mean-field
        interaction of core-active orbitals and :math:`g_{pqrs}` are the active integrals
        in chemist ordering.
        """
        c0, c1, c2 = self.get_active_integrals(mo_coeff)
        return sum(c0,
                   torch.einsum('pq, pq', c1, one_rdm),
                   torch.einsum('pqrs, pqrs', c2, two_rdm))
        
    
    def get_active_integrals(self, mo_coeff):
        int1e = self.int1e_mo(mo_coeff)
        int2e = self.int2e_mo(mo_coeff)
        return integrals.molecular_hamiltonian_coefficients(
            self.nuc, int1e, int2e, self.occ_idx, self.act_idx)
        
    def int1e_transform(self, mo_coeff):
        """1e MO-integrals in chemists order"""
        return mo_coeff.T @ self.int1e_AO @ mo_coeff

    def int2e_mo(self, mo_coeff):
        """2e MO-integrals in chemists order"""
        return uniform_4index_transform(self.int2e_AO, mo_coeff)

    def update_integrals(self, mo_coeff):
        self.int1
   
    def orbital_gradient(self, one_rdm, two_rdm):
        return 2 * (self.fock_generalized(one_rdm, two_rdm) - torch.t(
            self.fock_generalized(one_rdm, two_rdm)))
        
    def update_mo(self, mo_coeff):
        self.mo_coeff = mo_coeff